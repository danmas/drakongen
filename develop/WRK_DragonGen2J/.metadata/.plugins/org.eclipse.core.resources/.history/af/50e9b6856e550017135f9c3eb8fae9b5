
//--dg-- Класс DrakonUtils
//--dg-- упоминание о DrakonGen2
/**
* Этот текст сгенерирован программой DrakonGen2
* @author Erv -
*/
//--dg-- package//--dg-- imports
package ru.erv.drakongen;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.JSONValue;
import org.json.simple.parser.ParseException;

import com.tinkerpop.blueprints.pgm.Edge;
import com.tinkerpop.blueprints.pgm.Graph;
import com.tinkerpop.blueprints.pgm.Vertex;

import cb.dfs.trail.utils.Strings;
import ru.erv.drakongen.utils.*;

//--dg-- class DrakonUtils
public class DrakonUtils {
	// --dg-- константы
	public static final String PREF_MARKER_CDATA = "<data key=\"d4\"><![CDATA[";
	public static final String PREF_MARKER_DG2J = "<DG2J code_mark=\"";
	public static final String PREF_CODE_CDATA = "<data key=\"d6\"><![CDATA[";
	public static final String POST_CODE_CDATA = "]]></data>";

	public final static String DI_EXT_NEXT = "next";
	public final static String DI_DG_BEG = "DG_BEG";
	public final static String DI_SI_BEG = "SI_BEG";
	public final static String DI_SI_END = "SI_END";
	public final static String DI_CLASS_END = "CLASS_END";
	public final static String DI_COMPIL_BEG = "COMPIL_BEG";
	public final static String DI_COMPIL_END = "COMPIL_END";
	public final static String DI_SH_BEG = "SH_BEG";
	public final static String DI_SH_END = "SH_END";
	public final static String DI_PROC_BEG = "PROC_BEG";
	public final static String DI_PROC_END = "PROC_END";
	public final static String DI_WR_RES_FILE = "WR_RES_FILE";
	public final static String DI_AC = "AC";
	public final static String DI_ACTION = "ACTION";
	public final static String DI_SUB_COMPIL = "SUB_COMPIL";
	public final static String DI_IF = "IF";
	public final static String DI_RY = "RY";
	public final static String DI_DN = "DN";
	public final static String DI_EI = "EI";
	public final static String DI_UK = "UK";
	public final static String DI_FOR_BEG = "FOR_BEG";
	public final static String FOR_EACH_BEG = "FOR_EACH_BEG";
	public final static String DI_FOR_END = "FOR_END";
	public final static String DI_REF = "REF";
	public final static String DI_BREAK = "BREAK";

	public final static String DI_CASE = "CASE";
	public final static String DI_DEFAULT = "DEFAULT";
	public final static String DI_SW = "SWITCH";
	public final static String DI_RETURN = "RETURN";
	public final static String DI_INSERT = "INSERT";
	public final static String DI_OUTPUT = "OUTPUT";
	public final static String DI_START_ACTS = "START_ACTS";
	public final static String DI_NATIVE_CODE = "NATIVE_CODE";
	public final static String DI_SUBSTITUTES = "SUBSTITUTES"; 
	
	public static final String REM_TRY = "DI_TRY";
	public static final String REM_CATCH = "DI_CATCH";
	public static final String REM_PROC_DOC = "DI_PROC_DOC";
	public static final String REM_CALL_PROC = "DI_CALL_PROC";

	public final static String RELEASE_TYPE_CODE_JAVA = "CODE_JAVA";
	public final static String RELEASE_TYPE_CODE_AS = "CODE_AS";

	public static enum IcTypes {
		DI_EXT_NEXT, DI_DG_BEG, DI_SI_BEG, DI_SI_END, DI_CLASS_END, DI_COMPIL_BEG
		, DI_COMPIL_END, DI_SH_BEG, DI_SH_END, DI_PROC_BEG, DI_PROC_END, DI_WR_RES_FILE, DI_AC, DI_ACTION, DI_SUB_COMPIL, DI_IF, DI_RY, DI_DN, DI_EI, DI_UK, DI_FOR_BEG, FOR_EACH_BEG, DI_FOR_END, DI_REF, DI_BREAK

		,DI_CASE, DI_DEFAULT, DI_SW, DI_RETURN, DI_INSERT, DI_OUTPUT, DI_START_ACTS
		, DI_NATIVE_CODE, DI_SUBSTITUTES

		,REM_TRY, REM_CATCH, REM_PROC_DOC, REM_CALL_PROC;
	};

	// --dg-- переменные
	// --dg-- Конструктор
	public DrakonUtils() {
		// --dg-- //--dg--
	}

	// --dg-- Получение маркера кода
	public static String getCodeMark(Vertex node) {
		// --dg-- получаем маркер кода
		if (node == null)
			return "";
		String type = (String) node.getProperty("code_mark");
		if (type == null)
			type = "";
		// --dg-- маркер
		return type;
	}

	// --dg-- Получение типа иконы узла
	public static String getIconType(Vertex node) {
		// --dg-- получаем иконый тип
		if (node == null)
			return "";
		String type = (String) node.getProperty("type");
		if (type == null)
			type = "";
		// --dg-- тип
		return type;
	}

	// --dg-- Получение типа иконы узла
	public static boolean isIconType(Vertex node, String istype) {
		// --dg-- получаем иконый тип
		if (node == null)
			return false;
		String type = (String) node.getProperty("type");
		//System.out.println("--------- "+(String) node.getProperty("comment") );
		if (type == null)
			return false;
		
		return type.contains(istype);
	}
	
	
	/**
	 * Заполняем катпу подстановок Strings
	 * @param node
	 */
	public void fillSubst(Vertex node) {
		String js = getCode(node);
		if(!Strings.isStringEmpty(js)) {
        try {
            JSONObject genreJsonObject = (JSONObject) JSONValue.parseWithException(js);
//            if(genreJsonObject.get("type")!="SUBST") {
//            	return;
//            }
            JSONArray dataset = (JSONArray) genreJsonObject.get("replacements");
            
            for (Object o : dataset) {
                JSONObject jo = (JSONObject) o;
                Strings.setSubstValue((String)jo.get("what"),(String)jo.get("to"));
                System.out.println(jo.get("what"));
                System.out.println(jo.get("to"));
            }            
        } catch (ParseException e) {
            e.printStackTrace();
        }
		}
		
	}
	
	// --dg-- Получение комента из узла
	public static String getComment(Vertex node) {
		// --dg-- получаем коментарий
		if (node == null)
			return "";
		String ret = (String) node.getProperty("comment");
		//-- выполняем подстановки
		if(ret!=null && Strings.getSubstSize() > 0) {
			ret = Strings.doAllPercSubst(ret);
		} 
		// --dg-- ком.
		return ret;
	}

	// --dg-- Возвращает код из узла
	public static String getCode(Vertex node) {
		//System.out.println(" ------- getCode() :" );
		// --dg-- строим код
		if (node == null)
			return "";
		
		if(isIconType(node,"CODE_FROM_LABEL")) {
			String s = (String) node.getProperty("comment");
			if(s == null) {
				return "";
			}
			return s;
		}
		String s = (String) node.getProperty("code");
		//-- выполняем подстановки
		if(s!=null && Strings.getSubstSize() > 0) {
			s = Strings.doAllPercSubst(s);
		} 
        if(s==null) {
        	s="";
        }
		return s;
	}

//	public static String getCodeFromLabel(Vertex node) {
//		// --dg-- строим код
//		if (node == null)
//			return "";
//		return (String) node.getProperty("comment");
//		// --dg-- //--dg--
//	}

	// --dg-- message()
	public static void message(String str) {
		// --dg-- строим код
		System.out.println(str);
		// --dg-- //--dg--
	}

	// --dg-- error()
	public static void error(String str) {
		// --dg-- строим код
		System.err.println(str);
		// --dg-- //--dg--
	}

	// --dg-- debug()
	public static void debug(String str) {
		// --dg-- строим код
		if (Settings.isDebug())
			System.out.println(str);
		// --dg-- //--dg--
	}

	// --dg-- getInDegree()
	public static int getInDegree(Vertex v) {
		// --dg-- строим код
		int i = 0;
		for (Edge e : v.getInEdges()) {
			if (!DrakonUtils.isReferenceEdge(e))
				i++;
		}
		return i;

		// --dg-- //--dg--
	}

	// --dg-- getOutDegree()
	public static int getOutDegree(Vertex v) {
		// --dg-- строим код
		int i = 0;
		for (Edge e : v.getOutEdges()) {
			if (!DrakonUtils.isReferenceEdge(e))
				i++;
		}
		return i;

		// --dg-- //--dg--
	}

	// --dg-- getInNode()
	public static Vertex getInNode(Vertex v, int num) {
		// --dg-- строим код
		if (v == null)
			return null;
		int i = 0;
		for (Edge e : v.getInEdges()) {
			if (DrakonUtils.isReferenceEdge(e))
				continue;
			if (i == num)
				return e.getOutVertex();
			i++;
		}
		return null;
		// --dg-- //--dg--
	}

	// --dg-- getOutNode()
	public static Vertex getOutNode(Vertex v, int num) {
		// --dg-- строим код
		if (v == null)
			return null;
		int i = 0;
		for (Edge e : v.getOutEdges()) {
			if (DrakonUtils.isReferenceEdge(e))
				continue;
			if (i == num)
				return e.getInVertex();
			i++;
		}
		return null;
		// --dg-- //--dg--
	}

	// --dg-- getOutEdge()
	public static Edge getOutEdge(Vertex v, int num) {
		// --dg-- строим код
		if (v == null)
			return null;
		int i = 0;
		for (Edge e : v.getOutEdges()) {
			if (DrakonUtils.isReferenceEdge(e))
				continue;
			if (i == num)
				return e;
			i++;
		}
		return null;
		// --dg-- //--dg--
	}

	// --dg-- isEdgeYes()
	public static boolean isEdgeYes(Edge edge) {
		// --dg-- строим код
		if (edge == null)
			return false;

		String di_type_edge = (String) edge.getProperty("dglabel");
		if (di_type_edge == null)
			return false;

		if (di_type_edge.toUpperCase().equals("ДА") || di_type_edge.toUpperCase().equals("YES"))
			return true;
		return false;
		// --dg-- //--dg--
	}

	// --dg-- isReferenceEdge()
	public static boolean isReferenceEdge(Edge edge) {
		// --dg-- строим код
		if (edge == null)
			return false;

		String di_type_edge = (String) edge.getProperty("type");
		if (di_type_edge == null)
			return false;

		if (di_type_edge.toUpperCase().equals("REF"))
			return true;
		return false;
		// --dg-- //--dg--
	}

	// --dg-- isLabelCodeEdge()
	public static boolean isLabelCodeEdge(Edge edge) {
		// --dg-- строим код
		if (edge == null)
			return false;

		String di_type_edge = (String) edge.getProperty("type");
		if (di_type_edge == null)
			return false;

		if (di_type_edge.toUpperCase().equals("LABEL_CODE"))
			return true;
		return false;
		// --dg-- //--dg--
	}

	// --dg-- main
	public static void main(String[] args) {
		// --dg-- //--dg--
	}
	// --dg--

} // -- конец класса
